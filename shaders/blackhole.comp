#version 460 core

layout (local_size_x = 8, local_size_y = 8) in;

layout (rgba32f, binding = 0) uniform image2D accumImage;
layout (binding = 4) uniform samplerCube starCube;
uniform sampler3D diskVolume;

uniform vec2 resolution;
uniform vec3 camPos;
uniform vec3 camForward;
uniform vec3 camRight;
uniform vec3 camUp;

uniform vec3 bh_position;
uniform float bh_rs;
uniform float bh_rg;
uniform float bh_spin;

uniform float disk_rMin;
uniform float disk_rMax;
uniform float disk_zMin;
uniform float disk_zMax;

uniform int diskNR;
uniform int diskNTheta;
uniform int diskNZ;

uniform float uTime;

const float PI = 3.14159265358979323846;

void sampleDiskVolume(
    vec3 posWorld,
    float ds,
    inout vec3 accumColour,
    inout float accumAlpha,
    inout bool hitDisk
)
{
    vec3 rel = posWorld - bh_position;

    if (length(rel) < bh_rs)
        return;

    float r = length(rel.xz);
    float y = rel.y;
    float theta = atan(rel.z, rel.x);
    theta = fract(theta / (2.0 * PI) + 0.5);

    if (r < disk_rMin || r > disk_rMax || abs(y) > disk_zMax * 2.5)
        return;

    hitDisk = true;

    vec3 uvw = vec3(
        theta,
        (r - disk_rMin) / (disk_rMax - disk_rMin),
        (y - disk_zMin) / (disk_zMax - disk_zMin)
    );

    vec4 d = texture(diskVolume, uvw);
    float density = d.r;
    float temp = d.g;

    vec3 diskColourCold = vec3(1.0, 0.4, 0.1);
    vec3 diskColourHot  = vec3(1.0, 1.0, 0.95);
    vec3 baseColour = mix(diskColourCold, diskColourHot, temp);

    vec3 tangential = normalize(vec3(-rel.z, 0.0, rel.x));
    float orbitalSpeed = sqrt(1.0 / (r + 1e-4));
    vec3 vel = tangential * orbitalSpeed;

    float beta = dot(vel, normalize(-camPos + posWorld));
    float gamma = 1.0 / sqrt(max(1.0 - dot(vel, vel), 1e-4));
    float delta = 1.0 / (gamma * (1.0 - beta));
    delta = clamp(delta, 0.5, 2.0);

    float dopplerStrength = 7.0;
    float brightness = pow(delta, dopplerStrength);
    vec3 colourShift = vec3(1.0 / delta, 1.0, delta);
    baseColour *= colourShift * brightness;

    float shadowWidth = 0.1;
    float shadowStrength = 0.9;
    float shadowFalloff = smoothstep(shadowWidth, 0.0, abs(y / disk_zMax));
    float shadowFactor = 1.0 - shadowStrength * shadowFalloff;
    baseColour *= shadowFactor;

    float heightAtten = exp(-pow(abs(y) / (disk_zMax * 0.7), 2.5));
    float equatorialDark = exp(-pow(abs(y) / (disk_zMax * 0.25), 3.0));
    float verticalMix = mix(heightAtten, equatorialDark, 0.7);
    baseColour *= mix(0.2, 1.0, verticalMix);

    float halo = exp(-pow(abs(y) / (disk_zMax * 2.5), 3.0));
    vec3 haloColour = baseColour * 0.3 * halo;

    float corona = exp(-pow(abs(y) / (disk_zMax * 4.0), 2.0)) * 0.5;
    vec3 coronaColour = baseColour * vec3(1.2, 0.9, 0.7) * corona;

    float emissiveStrength = mix(3.0, 15.0, temp);
    float absorption = exp(-density * ds * 6.0);

    vec3 emitted =
        (baseColour * emissiveStrength * density +
         haloColour +
         coronaColour) * ds;

    accumColour += emitted * (1.0 - absorption) * (1.0 - accumAlpha);
    accumAlpha  += (1.0 - absorption) * (1.0 - accumAlpha);

    accumColour = clamp(accumColour, 0.0, 20.0);
}


void main()
{
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    if (pix.x >= int(resolution.x) || pix.y >= int(resolution.y))
        return;

    vec2 uv = (vec2(pix) + 0.5) / resolution * 2.0 - 1.0;
    uv.x *= resolution.x / resolution.y;

    vec3 rayDir = normalize(
        camForward +
        uv.x * camRight +
        uv.y * camUp
    );

    vec3 toBH = bh_position - camPos;
    float tClosest = dot(toBH, rayDir);
    vec3 pClosest = camPos + rayDir * tClosest;
    float b = length(pClosest - bh_position);

    

    vec3 colour = vec3(0.0);
    float alpha = 0.0;
    bool hitDisk = false;

    const int MAX_STEPS = 2000;
    float t = 0.0;
    float ds = 0.15; 

    for (int i = 0; i < MAX_STEPS; i++)
    {
        vec3 pos = camPos + rayDir * t;

        sampleDiskVolume(
            pos,
            ds,
            colour,
            alpha,
            hitDisk
        );

        if (alpha > 0.995)
            break;

        t += ds;

        if (t > disk_rMax * 2.0)
            break;
    }
    
    if (hitDisk == false && tClosest > 0.0 && b < bh_rs)
    {
        imageStore(accumImage, pix, vec4(0.0, 0.0, 0.0, 1.0));
        return;
    }
    float photonRadius = 1.5 * bh_rs;
    float ringWidth = 0.02 * bh_rs;
    float ring = exp(-pow((b - photonRadius) / ringWidth, 2.0));
    colour += ring * vec3(1.15, 1.1, 1.0);

    if (alpha < 0.99)
        colour += texture(starCube, rayDir).rgb;

    imageStore(accumImage, pix, vec4(colour, 1.0));
}

