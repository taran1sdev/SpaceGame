#version 460 core

layout (local_size_x = 8, local_size_y = 8) in;

layout (rgba32f, binding = 0) uniform image2D accumImage;

layout (binding = 4) uniform samplerCube starCube;

uniform vec2 resolution;
uniform vec3 camPos;
uniform vec3 camForward;
uniform vec3 camRight;
uniform vec3 camUp;

uniform vec3 bh_position;
uniform float bh_rs;
uniform float bh_rg;
uniform float bh_spin;

uniform sampler3D diskVolume;

uniform float disk_rMin;
uniform float disk_rMax;
uniform float disk_zMin;
uniform float disk_zMax;

uniform int diskNR;
uniform int diskNTheta;
uniform int diskNZ;

uniform float uTime;

const float PI = 3.1415926535;

float noise(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453123);
}

void sampleDiskVolume(vec3 posWorld, float ds,
                      inout vec3 accumColour,
                      inout float accumAlpha,
                      inout bool hitDisk)
{
    vec3 rel = posWorld - bh_position;
    float r = length(rel.xz);
    float y = rel.y;
    float theta = atan(rel.z, rel.x);
    
    float u = theta * (0.5 / PI) + 0.5;
    float uWrap = fract(u);

    if (r < disk_rMin || r > disk_rMax || abs(y) > disk_zMax * 2.5)
        return;
    hitDisk = true;
    
    float ur = (r - disk_rMin) / (disk_rMax - disk_rMin);
    ur = clamp(ur, 0.0, 1.0);

    float uz = 0.5 + 0.5 * y / disk_zMax;
    uz = clamp(uz, 0.0, 1.0);

    vec4 d = texture(diskVolume, vec3(uWrap, ur, uz));

    float density = d.r;
    float temp = d.g;

    vec3 diskColourCold = vec3(1.0, 0.4, 0.1);
    vec3 diskColourHot  = vec3(1.0, 1.0, 0.95);
    vec3 baseColour = mix(diskColourCold, diskColourHot, temp);

    vec3 tangential = normalize(vec3(-rel.z, 0.0, rel.x));
    float orbitalSpeed = sqrt(1.0 / (r + 1e-4));
    vec3 vel = tangential * orbitalSpeed;

    float beta = dot(vel, normalize(-camPos + posWorld));
    float gamma = 1.0 / sqrt(1.0 - dot(vel, vel));
    float delta = 1.0 / (gamma * (1.0 - beta));
    delta = clamp(delta, 0.5, 2.0);

    float dopplerStrength = 7.0;
    float brightness = pow(delta, dopplerStrength);
    vec3 colourShift = vec3(1.0 / delta, 1.0, delta);
    baseColour *= colourShift * brightness;

    float shadowWidth = 0.1;
    float shadowStrength = 0.9;
    float shadowFalloff = smoothstep(shadowWidth, 0.0, abs(y / disk_zMax));
    float shadowFactor = 1.0 - shadowStrength * shadowFalloff;
    baseColour *= shadowFactor;

    float heightAtten = exp(-pow(abs(y) / (disk_zMax * 0.7), 2.5));
    float equatorialDark = exp(-pow(abs(y) / (disk_zMax * 0.25), 3.0));
    float verticalMix = mix(heightAtten, equatorialDark, 0.7);
    baseColour *= mix(0.2, 1.0, verticalMix);

    float halo = exp(-pow(abs(y) / (disk_zMax * 2.5), 3.0));
    vec3 haloColour = baseColour * 0.3 * halo;
    float corona = exp(-pow(abs(y) / (disk_zMax * 4.0), 2.0)) * 0.5;
    vec3 coronaColour = baseColour * vec3(1.2, 0.9, 0.7) * corona;

    float emissiveStrength = mix(3.0, 15.0, temp);
    float absorption = exp(-density * ds); 
    vec3 emitted = 
        (baseColour * emissiveStrength * density + haloColour + coronaColour) * (ds * 6.0);
    
    accumColour += emitted * (1.0 - absorption) * (1.0 - accumAlpha);
    accumAlpha += (1.0 - absorption) * (1.0 - accumAlpha);
    accumColour = clamp(accumColour, 0.0, 20.0);
}

vec3 rotateAroundAxis(vec3 v, vec3 axis, float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return v * c + cross(axis, v) * s + axis * dot(axis, v) * (1.0 - c);
}

bool intersectCylinderY(vec3 o, vec3 d, float R, out float tEnter, out float tExit) {
    float a = d.x*d.x + d.z*d.z;
    float b = 2.0 * (o.x*d.x + o.z*d.z);
    float c = o.x*o.x + o.z*o.z - R*R;

    if (a < 1e-8) return false;

    float disc = b*b - 4.0*a*c;
    if (disc < 0.0) return false;

    float sdisc = sqrt(disc);
    float inv2a = 0.5 / a;
    float t0 = (-b - sdisc) * inv2a;
    float t1 = (-b + sdisc) * inv2a;

    tEnter = min(t0, t1);
    tExit  = max(t0, t1);
    return true;
}

bool intersectSphere(vec3 o, vec3 d, float R, out float tHit) {
    float b = dot(o, d);
    float c = dot(o, o) - R*R;
    float h = b*b - c;
    
    if (h < 0.0) return false;
    h = sqrt(h);
    tHit = -b - h;
    return tHit > 0.0;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(resolution.x) || pixel.y >= int(resolution.y))
        return;

    vec2 uv = (vec2(pixel) + 0.5) / resolution * 2.0 - 1.0;
    float aspect = resolution.x / resolution.y;
    uv.x *= aspect;

    vec3 rayDir = normalize(camForward + uv.x * camRight + uv.y * camUp);
    vec3 rayOrg = camPos;

    vec3 toBH = bh_position - rayOrg;
    float tClosest = dot(toBH, rayDir);                  
    vec3  pClosest = rayOrg + rayDir * tClosest;
    vec3  dVec     = bh_position - pClosest;              
    float b        = length(dVec);                         

    float shadowRadius = 2.6 * bh_rs;                         
    bool inShadow = (tClosest > 0.0) && (b < shadowRadius);

    float lensOuter = 40.0 * bh_rs;                          
    float lensInner = 3.0  * bh_rs;                         
    float lensFade  = smoothstep(lensOuter, lensInner, b);

    vec3 axis = normalize(cross(rayDir, dVec));
    if (length(axis) < 1e-6) axis = normalize(cross(rayDir, vec3(0.0, 1.0, 0.0)));

    float k = 2.0 * bh_rs;                                    
    float angle = clamp(k / max(b, 1e-3), 0.0, 0.9);         
    vec3 rayDirLensed = rotateAroundAxis(rayDir, axis, angle * lensFade);

    float bCrit = 2.6 * bh_rs;
    float ringW = 0.15 * bh_rs;
    float ring = exp(-pow((b - bCrit) / max(ringW, 1e-3), 2.0)) * lensFade;
    vec3 ringColour = vec3(1.0, 0.9, 0.7) * (3.0 * ring);

    vec3 starColour = texture(starCube, rayDirLensed).rgb;

    if (inShadow) starColour = vec3(0.0);

    vec3 accumColour = vec3(0.0);
    float accumAlpha = 0.0;
    bool hitDisk = false;

    vec3 o = rayOrg - bh_position;
    vec3 d = rayDirLensed;

    float tCylEnter, tCylExit;
    bool hitOuter = intersectCylinderY(o, d, disk_rMax, tCylEnter, tCylExit);

    float yMax = disk_zMax * 2.5;
    float tY0 = (-yMax - o.y) / d.y;
    float tY1 = ( yMax - o.y) / d.y;
    float tYEnter = min(tY0, tY1);
    float tYExit  = max(tY0, tY1);

    float tEnter = 0.0;
    float tExit  = 0.0;

    if (hitOuter)
    {
        tEnter = max(tCylEnter, tYEnter);
        tExit  = min(tCylExit,  tYExit);

        if (tExit > max(tEnter, 0.0))
        {
            float t = max(tEnter, 0.0);

            const float ds_vol = 0.009;                         
            float maxLen = min(tExit - t, 4000.0);             
            int steps = int(clamp(maxLen / ds_vol, 0.0, 1024.0));

            for (int i = 0; i < steps && accumAlpha < 0.995; ++i)
            {
                vec3 posWorld = rayOrg + d * t;
                sampleDiskVolume(posWorld, ds_vol, accumColour, accumAlpha, hitDisk);
                t += ds_vol;
            }
        }
    }

    vec3 finalColour = accumColour + (1.0 - accumAlpha) * starColour + ringColour;

    if (inShadow && !hitDisk) finalColour = vec3(0.0);

    imageStore(accumImage, pixel, vec4(finalColour, 1.0));
}
