#version 460 core
layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba16f, binding = 0) uniform image2D outImage;

layout(binding = 1) uniform sampler2D sceneColour;   
layout(binding = 2) uniform sampler2D diskBase;
layout(binding = 3) uniform sampler2D diskTop;
layout(binding = 4) uniform sampler2D diskBottom;

uniform vec2 resolution;

uniform vec3 bh_position;
uniform vec2  bh_screenPos;
uniform float bh_rs;

uniform float horizonRadius;  
uniform float lensInnerRadius;
uniform float lensOuterRadius;

uniform float lensStrength;    

uniform float ringRadius;      
uniform float ringWidth;      
uniform float ringIntensity; 
uniform vec3  ringColour;   

vec4 sampleScene(vec2 uv) {
    uv = clamp(uv, vec2(0.0), vec2(1.0));
    return texture(sceneColour, uv);
}

void main()
{
    ivec2 px = ivec2(gl_GlobalInvocationID.xy);
    if (px.x >= int(resolution.x) || px.y >= int(resolution.y)) return;

    vec2 uv = (vec2(px) + 0.5) / resolution;

    float aspect = resolution.x / resolution.y;

    vec2 delta = uv - bh_screenPos;
    delta.x *= aspect;

    float dist = length(delta);
    
    // This allows us to sample the front disk unwarped and the back warped
    // to produce the wrapping around BH effect
    float equatorHalfWidth = horizonRadius * 0.7;
    float equatorFeather = horizonRadius * 0.2;

    float fromEquator = abs(delta.y);

    float warpW = smoothstep(
            equatorHalfWidth, equatorHalfWidth + equatorFeather, fromEquator);

    float ringT = 1.0 - smoothstep(ringWidth, ringWidth * 2.0, abs(dist - ringRadius));
    vec3 ring = ringColour * ringIntensity * ringT;

    vec2 dir = delta / max(dist, 1e-6);

    float x = 1.0 - clamp(dist / lensOuterRadius, 0.0, 1.0);

    float t = x * x * (3.0 - 2.0 * x); 
    
    float compressed = dist * (1.0 - lensStrength * t);

    vec2 uvWarped = bh_screenPos + vec2(
            dir.x / aspect,
            dir.y) * compressed;
    
    vec2 dw = uvWarped - bh_screenPos;
    dw.x *= aspect;
    float distW = length(dw);
    
    vec3 scene = sampleScene(uvWarped).rgb;
     
    vec4 baseDisk = texture(diskBase, uv);
    vec4 dt = texture(diskTop, uvWarped);
    vec4 db = texture(diskBottom, uvWarped);
    
    float soft = horizonRadius * 0.05;
    float outsideBH = smoothstep(horizonRadius, horizonRadius + soft, dist);
    
    dt.a *= outsideBH;
    db.a *= outsideBH;
    
    //vec4 dt = mix(dtFlat, dtWarp, warpW);
    //vec4 db = mix(dbFlat, dbWarp, warpW);
    
    
    vec3 colour = scene * outsideBH;
    
    colour = mix(colour, baseDisk.rgb, baseDisk.a);

    colour = mix(colour, dt.rgb, clamp(dt.a, 0.0, 1.0));
    colour = mix(colour, db.rgb, clamp(db.a, 0.0, 1.0));

    colour += ring;

    imageStore(outImage, px, vec4(colour, 1.0));

}

