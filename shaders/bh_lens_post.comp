#version 460 core
layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba16f, binding = 0) uniform image2D outImage;

layout(binding = 1) uniform sampler2D sceneColour;   
layout(binding = 2) uniform sampler2D diskOverlay; 

uniform vec2 resolution;

uniform vec2  bh_uv;

uniform float horizonRadius;  
uniform float lensInnerRadius;
uniform float lensOuterRadius;

uniform float lensStrength;    

uniform float ringRadius;      
uniform float ringWidth;      
uniform float ringIntensity; 
uniform vec3  ringColour;   

vec4 sampleScene(vec2 uv) {
    uv = clamp(uv, vec2(0.0), vec2(1.0));
    return texture(sceneColour, uv);
}

void main()
{
    ivec2 px = ivec2(gl_GlobalInvocationID.xy);
    if (px.x >= int(resolution.x) || px.y >= int(resolution.y)) return;

    vec2 uv = (vec2(px) + 0.5) / resolution;

    float aspect = resolution.x / resolution.y;

    vec2 delta = uv - bh_uv;
    delta.x *= aspect;

    float dist = length(delta);

    if (dist > lensOuterRadius)
    {
        imageStore(outImage, px, texture(sceneColour, uv));
        return;
    }

    if (dist < horizonRadius) {
        imageStore(outImage, px, vec4(0.0, 0.0, 0.0, 1.0));
        return;
    }

    float ringT = 1.0 - smoothstep(ringWidth, ringWidth * 2.0, abs(dist - ringRadius));
    vec3 ring = ringColour * ringIntensity * ringT;

    vec2 dir = delta / max(dist, 1e-6);

    float x = 1.0 - clamp(dist / lensOuterRadius, 0.0, 1.0);

    float t = x * x * (3.0 - 2.0 * x); 
    
    float compressed = dist * (1.0 - lensStrength * t);

    vec2 uvWarped = bh_uv + vec2(
            dir.x / aspect,
            dir.y) * compressed;

    vec3 scene = sampleScene(uvWarped).rgb;
    vec4 disk  = texture(diskOverlay, uv);

    scene = mix(scene, disk.rgb, disk.a);
    scene += ring;

    imageStore(outImage, px, vec4(scene, 1.0));
}

